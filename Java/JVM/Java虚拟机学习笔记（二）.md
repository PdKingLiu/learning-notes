@[toc]
# 对象的创建
通常情况下，我们是通过new指令完成一个对象的创建的。

虚拟机在接受到一个new指令会做如下操作：

1. **判断对象的类是否加载、链接、初始化**
	虚拟机在接收到一条new指令时，首先会检查这个指令的参数是否在常量池中定位到一个类的引用，并且检查这个符号引用代表的类是否被类加载器加载、链接和初始化。

2. **为对象分配内存**
	类加载完成后，接着会在Java堆中划分一块内存区域分配给对象。内存分配根据Java堆是否规整，有两种方式：
	
	- 指针碰撞：如果Java堆整的内存是规整的，则分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离。
	- 空闲列表：如果Java堆是不规整的，则需要Java虚拟机维护一个列来记录哪些内存是可用的，在分配的时候从列表中查询到足够大的内存分配给对象，并更新列表记录。

3. **处理并发安全问题**
	创建对象是一个频繁的操作，所以要解决并发问题，有两种方式：
 	- 对分配空间的动作进行同步，保证操作的原子性
 	- 每个线程在Java堆预先分配一小块内存，这块内存叫做本地分配缓冲（TLAB）。线程需要分配内存时，就在对应线程的的TLAB上分配内存，当TLAB用完并且分配到了新的TLAB时，这时才需要同步锁定。

4. **初始化分配到的内存空间**
将分配到的内存，除了对象头都初始化为零值。

5. **设置对象的对象头**
	将对象的所属类、对象的HashCode和对象的GC分带年龄等数据存储在对象的对象头。
6. **执行init方法进行初始化**
	执行init方法，初始化对象的成员变量、调用类的构造方法，这样就完成了一个对象的创建。

# 对象的堆内存分布
Java对象在堆内存中内存布局分为三个区域，分别是对象头、实例数据、对齐填充。

- 对象头：对象头包括两部分信息，分别是Mark World和元数据指针。
	Mark World用于存储运行时数据，比如hashcode，锁状态标志、GC分带年龄、线程持有的锁等等。
	元数据用于指向方法区中目标类的元数据，通过元数据可以确定对象的具体类型。
- 实例填充：用于存储对象中的各种类型的字段信息。
- 对齐填充：不一定存在，通常起到一个占位的作用。

Mark world在HotSpot中的实现类为markOop.hpp，markOop被设计成一个非固定的数据结构，这是为了在极小的控件中存储尽量对的数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101116051690.png)
数据类型解释：

- hash：对象的哈希码
- age：对象的分代年龄
- biased_lock：偏向锁标示位
- lock：锁状态标示位
- JavaThread*持有偏向锁的线程ID
- epoch：偏向时间戳

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191011164942714.png)

# oop-klass模型
