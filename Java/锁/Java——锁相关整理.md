[TOC]

# 悲观锁与乐观锁
> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。

- **悲观锁**：**总是假设最坏的情况**，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样**别人想拿这个数据就会阻塞直到它拿到锁**（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
- **乐观锁**：**总是假设最好的情况**，每次去拿数据的时候**都认为别人不会修改**，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，**可以使用版本号机制和CAS算法实现**。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
- **使用场景**：从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是**多写的情况**，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下**用悲观锁就比较合适**。

# 乐观锁常见的两种实现方式
> 乐观锁一般会使用版本号机制或CAS算法实现

##  版本号机制

一般是在**数据表中加上一个数据版本号version字段**，表示数据被修改的次数，**当数据被修改时，version值会加一**。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才**读取到的version值为当前数据库中的version值相等时才更新**，否则重试更新操作，直到更新成功。

**比如**：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为$100 。

- 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
- 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
- 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
- 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

 ## CAS 
 即compare and swap（比较与交换），是一种有名的**无锁算法**。无锁编程，即**不使用锁的情况下实现多线程之间的变量同步**，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数
- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

**当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作**（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

[https://www.jianshu.com/p/21be831e851e](https://www.jianshu.com/p/21be831e851e)

## 自旋锁
自旋锁（spinlock）：是指**当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取**，直到获取到锁才会退出循环。

获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。

它是为实现**保护共享资源而提出一种锁机制**。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是**互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者**，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，**如果资源已经被占用**，**资源申请者只能进入睡眠状态**。但是**自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁**。

 **缺点**：
- 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程**进入循环等待，消耗CPU**。使用不当会造成CPU使用率极高。
- 上面Java实现的**自旋锁不是公平的**，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。

**优点**：

- 自旋锁不会使线程状态发生切换，一直处于用户态，即**线程一直都是active**的；不会使线程进入阻塞状态，**减少了不必要的上下文切换**，执行速度快
- 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）

[https://blog.csdn.net/qq_34337272/article/details/81252853](https://blog.csdn.net/qq_34337272/article/details/81252853)
# synchronized 
## 对于synchronized 关键字的了解
synchronized关键字解决的是多个线程之间访问资源的同步性，**synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行**。

在 Java 早期版本中，**synchronized属于重量级锁**，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。**JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销**。

## synchronized的使用
- **修饰实例方法**：作用于**当前对象实例加锁**，进入同步代码前要获得当前对象实例的锁
- **修饰静态方法**：也就是给**当前类加锁**，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
- **修饰代码块**：指定加锁对象，**对给定对象加锁**，进入同步代码库前要获得给定对象的锁。

**总结**：synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

**双重校验锁实现对象单例（线程安全）**

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
uniqueInstance 采用 volatile 关键字修饰很有必要。

uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：

- 为 uniqueInstance 分配内存空间
- 初始化 uniqueInstance
- 将 uniqueInstance 指向分配的内存地址

由于 **JVM 具有指令重排的特性**，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

使用 **volatile 可以禁止 JVM 的指令重排**，保证在多线程环境下也能正常运行。

## synchronized底层原理
### 通过代码块

```java
public class SynchronizedDemo {
	public void method() {
		synchronized (this) {
			System.out.println("synchronized 代码块");
		}
	}
}
```

查看 SynchronizedDemo 类的相关字节码信息
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191017093642117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

### 修饰方法

```java
public class SynchronizedDemo2 {
	public synchronized void method() {
		System.out.println("synchronized 方法");
	}
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191017093924265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是 **ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法**，从而执行相应的同步调用。

## synchronized和ReentrantLock 的区别
- **两者都是可重入锁**：两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
- **synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**：synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
- **ReentrantLock 比 synchronized 增加了一些高级功能**：主要有三点：等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）
	- **ReentrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
	- **ReentrantLock可以指定是公平锁还是非公平锁**。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。
	- **synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制**，**ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法**。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，**用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的**。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。**如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题**，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。
- **性能**：在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 **JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了**。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。

# volatile
## Java内存模型
在 JDK1.2 之前，Java的内存模型实现总是**从主存（即共享内存）读取变量**，是不需要进行特别的注意的。而在当前的 Java 内存模型下，**线程可以把变量保存本地内存（）比如机器的寄存器）中**，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191017103459634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
要解决这个问题，就需要把变量声明为volatile，这就**指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取**。

说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是**防止指令重排序**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191017104020735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
## 原子性、可见性和有序性
**原子性**

基本数据类型**变量的读取和赋值操作是原子性操作**，这些操作是不能中断的。

```java
x = 3;	//1
y = x;	//2
```
语句1是原子性操作，语句二不是原子性操作，它包含两个操作：读取x的值，将x的值写入工作内存。

**可见性**

指的是线程之间的可见性。**一个线程修改的状态对于另一个线程是可见的**，也就是一个线程修改的结果，在另一个线程会立即看到。

一个共享变量被volatile修饰后，他会保证在修改后立即写入主存，其他线程读取的时候会从主存去读取。

普通的共享变量在被一个线程修改后，并不会立即写入主存，当其他线程读取该值时，主存中可能还是原来的旧值，这样就不能保证可见性。

**有序性**

**Java内存模型运行编译器和处理器对指令进行重排序**，虽然重排序不会影响到线程执行的正确性，但是**会影响到多线程并发执行的正确性**。可以通过volatile来保证有序性，进行指令优化时，在volatile标量之前的语句不能在volatile变量后面执行，在volatile变量之后的语句也不能在volatile变量前面执行。除了volatile，也可以通过synchronize和Lock保证有序性。

当一个共享变量被volatile修饰之后，就具备两个意义

- **一个线程修改变量的值时，对其他线程是可见的**。
- **禁止使用指令重排**。

## synchronize和volatile区别
- **volatile关键字**是线程同步的**轻量级实现**，所以volatile**性能**肯定比synchronized关键字要好。但是**volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
- **多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞**
- **volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证**。
- **volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性**。

# JDK6  synchronized 的优化
JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在**四中状态**，依次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级**。注意**锁可以升级不可降级**，这种策略是为了提高获得锁和释放锁的效率。

## 偏向锁
- 为了在没有多线程竞争的前提下，**减少传统的重量级锁使用操作系统互斥量产生的性能消耗。**

- 偏向锁在无竞争的情况下**会把整个同步都消除掉**。

- 偏向锁的“偏”就是偏心的偏，它的意思是会**偏向于第一个获得它的线程**，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！

- 但是对于锁**竞争比较激烈的场合，偏向锁就失效了**，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并**不会立即膨胀为重量级锁，而是先升级为轻量级锁**。

## 轻量级锁
- 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会**尝试使用一种称为轻量级锁**的优化手段。
- 轻量级锁本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。**轻量级锁的加锁和解锁都用到了CAS操作**。 
- 轻量级锁能够提升程序同步性能的依据是对于绝大部分锁在整个同步周期内都是不存在竞争的，这是一个经验数据。如果没有竞争，**轻量级锁使用 CAS 操作避免了使用互斥操作的开销**。但**如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作**，因此在**有锁竞争的情况下，轻量级锁比传统的重量级锁更慢**！如果锁**竞争激烈，那么轻量级将很快膨胀为重量级锁**！

## 自旋锁
- 轻量级锁失败后，虚拟机**为了避免线程真实地在操作系统层面挂起**，还会**进行一项称为自旋锁的优化手段**。
- 互斥同步**对性能最大的影响就是阻塞的实现**，因为挂起线程/恢复线程的操作都需要**转入内核态**中完成（**用户态转换到内核态会耗费时间**）。
- 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？因此，**为了让一个线程等待**，我们只需要让线程**执行一个忙循环（自旋），这项技术就叫做自旋**。
- 对于**互斥锁**，如果资源已经被占用，**资源申请者只能进入睡眠状态**。但是**自旋锁**不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，**调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁**，"自旋"一词就是因此而得名。

## 自适应的自旋锁
自适应的自旋锁带来的**改进**就是：**自旋的时间不在固定**了，而是和**前一次同一个锁上的自旋时间以及锁的拥有者的状态**来决定。

## 锁消除
锁消除理解起来很简单，它指的就是**虚拟机即使编译器在运行时**，如果**检测到那些共享数据不可能存在竞争**，那么就**执行锁消除**。锁消除可以**节省毫无意义的请求锁的时间**。

## 锁粗化
在遇到一连串地对**同一锁不断进行请求和释放的操作**时，虚拟机会**把所有的锁操作整合成锁的一次请求**，从而减少对锁的请求同步次数。