[toc]

# 哲学家就餐问题
**描述**

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112232309230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)

当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

如果哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。

```java
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        P(i);       // 拿起左边的筷子
        P((i+1)%N); // 拿起右边的筷子
        eat();
        V(i);
        V((i+1)%N);
    }
}
```

**操作系统中的死锁是指多个进程在运行过程中因为争夺资源造成的一种相互等待的情况。**

# 死锁必要条件
如果一个系统中下面四个条件同时满足，那么会引起引起死锁。

- **互斥**：至少有一个资源处于非共享模式，即一次只有一个进程使用，如果另一个进程申请该资源，那么申请进程必须等到该资源被释放为止。
- **占有并等待**：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。
- **非抢占**：资源不能被抢占，即资源只能在进程完成任务后自动释放。
- **环路等待**：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 死锁处理方法
## 鸵鸟策略

鸵鸟策略是指不采取任何措施。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法都是鸵鸟策略，即忽略它。

## 死锁检测与死锁恢复
不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

### 每种类型一个资源的死锁情况
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112174520808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
上图是资源分配图，其中方框表示资源。

圆圈表示进程。资源指向该进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

b是抽取出来的环，他满足了环路等待的条件，因此会发生死锁。

死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 每个类型多个资源的死锁检测

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112194851364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)

上图有**三个进程、四个资源**。

**各数据含义**

- E向量代表资源总量
- A向量代表资源剩余量
- C矩阵代表每个进程拥有的资源数量
- R矩阵代表每个进程请求的资源数量

**算法描述**

- 进程P1、P2所请求的资源都得不到满足，只有进程3可以，让进程P3执行，之后释放P3拥有的资源。
- 此时A=（2 2 2 0）。P2可以执行，执行后释放P2拥有的资源，A=（4 2 2 1）。
- P1也可以执行。所有进程都可以顺利执行，没有死锁。

**算法总结**

每个进程开始都不被标记，执行过程中可能被标记。

当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程P1，它所请求的资源小于等于A。
2. 如果找到了这样的进程，那么将C矩阵的第i行向量加到A中，标记该进程，并重复1。
3. 知道没有这样的进程，算法终止。

### 死锁恢复
- 利用回滚恢复——进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。
- 通过杀死进程恢复

## 死锁预防
死锁的预防即不允许死锁的发生，可以从破除死锁发生的四个必要条件入手。因为如果不具备上述四个必要条件，那么死锁就一定不会发生。

### 破坏互斥条件
通常不能通过否定互斥条件来预防死锁

### 破坏占有和等待条件
一种实现方式是所有进程在开始执行前请求所需要的全部资源。

### 破坏不可抢占条件
如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。

### 破坏环路
对资源进行排序，即每个进程访问资源的顺序是固定的。

**举例**

进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。

采用有序资源分配法：R1的编号为1，R2的编号为2。

PA：申请次序应是：R1，R2
PB：申请次序应是：R1，R2
这样就破坏了环路条件，避免了死锁的发生。

## 死锁避免
避免死锁同样是属于事先预防的策略，但并不是事先釆取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。

### 安全状态
安全状态是指系统能按某个顺序为每个进程分配资源并能避免死锁，那么系统状态就是安全的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112202417162.png)
**解释**

- 第二列Has表示已拥有的资源数
- 第三列Max表示总共需要的资源数
- Free表示还有可以使用的资源数

对于上图
1. 由a出发，让B进程拥有所需的所有资源，free变为1，成为图b，运行结束，释放B的资源，free变为5，成为图c。
2. 接着以同样的形式运行C和A，使得所有进程都能成功运行。
3. 所以图a的状态是安全的。

**定义**：即使所有进程突然请求对资源的最大请求，也仍然存在某种调度次序，能使每一个进程运行完毕，则称该状态是安全的。

### 单个资源的银行家算法
**描述**

一个银行家，他向一群客户分别承诺一定的贷款额度，算法要求做的是，判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则就予以分配。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112204737915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
比如上图中c就是不安全的状态，因此算法会拒绝之前的请求，从而避免进入图c中的状态。

**解释一下**

图b中，可以先把free的2个资源给C，然后C释放资源，free变为4，然后再分给B，接着，分给A，最后分给D，这样是安全状态。

而如果图b将一个free的资源分给了b，free变为1，这时不管再将free的1个资源给谁都不会达到最大的资源请求，从而导致了死锁。

### 多个资源的银行家算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191112210049124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVGYXJtZXJfXw==,size_16,color_FFFFFF,t_70)
**解释**

- 上图有五个进程，四个资源
- 左边表示已经分配的资源，右边表示已经分配的资源。
- E、P、A代表总资源、已分配资源、可用资源（A=1/0/2/0 代表剩余的四个资源的数量）

**算法描述**

- 查找右边的矩阵是否存在一行小于等于向量A，如果没有那么系统将会发生死锁。状态不安全
- 如果找到，将该进程标记为终止，并将它的资源加到A中。
- 重复上述两步，直到所有标记都标为终止，则状态是安全的。

如果一个状态是不安全的，就拒绝进入这个状态。

>参考
>https://blog.csdn.net/sunmc1204953974/article/details/46559589
>https://blog.csdn.net/weiyongle1996/article/details/71511956
>http://c.biancheng.net/cpp/html/2606.html